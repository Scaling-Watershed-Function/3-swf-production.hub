<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.353">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Francisco J. Guerrero">

<title>Results: Scaling Watershed Function</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="doc_result _interpretations_files/libs/clipboard/clipboard.min.js"></script>
<script src="doc_result _interpretations_files/libs/quarto-html/quarto.js"></script>
<script src="doc_result _interpretations_files/libs/quarto-html/popper.min.js"></script>
<script src="doc_result _interpretations_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="doc_result _interpretations_files/libs/quarto-html/anchor.min.js"></script>
<link href="doc_result _interpretations_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="doc_result _interpretations_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="doc_result _interpretations_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="doc_result _interpretations_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="doc_result _interpretations_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Results: Scaling Watershed Function</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Francisco J. Guerrero </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<section id="scaling-sediment-respiration-in-the-willamette-and-yakima-river-basins" class="level2">
<h2 class="anchored" data-anchor-id="scaling-sediment-respiration-in-the-willamette-and-yakima-river-basins">Scaling sediment respiration in the Willamette and Yakima River Basins</h2>
<p>In this project we built on Wollheim et al.,’s contribution on <a href="https://www.nature.com/articles/s41467-022-28630-z#:~:text=Superlinear%20scaling%20of%20cumulative%20biogeochemical,rivers%20within%20the%20Earth%20system.">superlinear scaling of watershed function in stream networks</a>. Wil gave a presentation at PNNL and a pdf of the slide deck is available <a href="https://github.com/Scaling-Watershed-Function/1-swf-knowledge.base/blob/main/visual_assets/4_seminars_presentations/wollheim_23_pnnl_scaling_seminar.pdf">here</a>. The driving question is to estimate the contribution of river networks to the global carbon cycle. To do so, we need to be able to estimate the total cumulative functions leading to CO2 emissions/sinks, that is, respiration, gross primary productivity.</p>
<p>Building on metabolic theory, it can be hypothesized that the total metabolic function of a stream network is function of its size (~watershed area). This function is a power law , which is characterized by scaling exponents. If the scaling exponent of cumulative function vs.&nbsp;watershed area is equal to one, we talk about <strong>isometric</strong> scaling, that is, function increases in direct proportion to size. If the scaling exponent is different from 1, we talk about <strong>allometric</strong> scaling, that is the changes in function can be larger or smaller than expected from network size. In the first case, we are talking about <strong>superlinear</strong> scaling, and in the later about <strong>sublinear</strong> scaling. For instance, it has been found that while the human heart scales linearly (isometric) with body size, the brain size scales sublinearly (allometrically) with body size (more <a href="https://www.nature.com/scitable/knowledge/library/allometry-the-study-of-biological-scaling-13228439/">here</a>).</p>
<p>So, what Wollheim and co-workers show in their paper is:</p>
<p>“We demonstrate <strong>allometric scaling</strong> [actually, superlinear] assuming spatially homogenous inputs of water (i.e., runoff; depth time<sup>−1</sup>) and non-point sources (mass area<sup>−1</sup> time<sup>−1</sup>), while local aquatic process rates may vary along gradients according to river size (Fig.&nbsp;<a href="https://www.nature.com/articles/s41467-022-28630-z#Fig1">1A</a>)…. While the assumption of uniform runoff is reasonable<sup><a href="https://www.nature.com/articles/s41467-022-28630-z#ref-CR29" title="Winston, W. E. &amp; Criss, R. E. Dependence of mean and peak streamflow on basin area in the conterminous United States. J. Earth Sci. 27, 83–88 (2016).">29</a>,<a href="https://www.nature.com/articles/s41467-022-28630-z#ref-CR30" title="Galster, J. C. Natural and anthropogenic influences on the scaling of discharge with drainage area for multiple watersheds. Geosphere 3, 260–271 (2007).">30</a></sup>, uniform non-point sources is likely often violated in real watersheds<sup><a href="https://www.nature.com/articles/s41467-022-28630-z#ref-CR31" title="Mineau, M. M., Wollheim, W. M. &amp; Stewart, R. J. An index to characterize the spatial distribution of land use within watersheds and implications for river network nutrient removal and export. Geophys. Res. Lett. 42, 10, (2015).">31</a></sup>. However, this assumption allows us to assess effects of network structure and hydrological conditions on cumulative biogeochemical function (Eq.&nbsp;<a href="https://www.nature.com/articles/s41467-022-28630-z#Equ1">1</a>).” Superlinear scaling in riverine function means that the contribution of larger watershed to carbon cycle, for instance, is disproportionately large when compared to the size of the watershed.</p>
<p>Since the River Corridor Model (Son et al., 2022) has predicted sediment respiration rates across the Columbia River Basin, we are in a good position to investigate if the allometric scaling demonstrated by Wollheim et al under their assumptions, would also explain the spatial patterns of sediment respiration predicted by the RCM. Furthermore we can assess whether or not allometric scaling holds under heterogeneous inputs of water / spatially varying hyporheic hydraulics and heterogeneous inputs of respiration substrates, linked to landscape spatial heterogeneity.</p>
<p>Besides the two assumptions employed by Wolheim et al., there are two conditions that would indicate that the scaling of ecosystem respiration vs.&nbsp;watershed area would be superlinear:</p>
<ol type="1">
<li>Cumulative benthic area (~stream surface area) scales superlinearly with watershed area.</li>
<li>Local respiration rates are positively correlated with watershed area.</li>
</ol>
<p>Our analysis indicate that despite meeting these two conditions across the Willamette and the Yakima river basins, the cumulative sediment respiration scales <strong>sublinearly</strong> (still allometric) with watershed area. The main reason behind this pattern could be the violation of the two assumptions of superlinear scaling.</p>
<p>We chose the Willamette and the Yakima as representative end-members of the climatic and hydrologic conditions observed across the Columbia River Basin, wet vs.&nbsp;arid.</p>
<p>The following plots illustrate the draft storyline for our publication:</p>
<section id="stream-surface-area-scales-superlinearly-with-watershed-area" class="level3">
<h3 class="anchored" data-anchor-id="stream-surface-area-scales-superlinearly-with-watershed-area">Stream Surface Area Scales Superlinearly with watershed area</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/guerrero_etal_23_stream_sa_scaling.png" class="img-fluid figure-img" alt="A scatter plot of stream surface area versus watershed area in two rivers within the Columbia River Basin"></p>
<figcaption class="figure-caption">Superlinear scaling of stream surface area with watershed area in the Willamette and Yakima River Basins. *Confidence intervals around the scaling exponents exclude 1</figcaption>
</figure>
</div>
</section>
<section id="local-respiration-rates-are-positively-correlated-with-watershed-area-except-in-larger-streams" class="level3">
<h3 class="anchored" data-anchor-id="local-respiration-rates-are-positively-correlated-with-watershed-area-except-in-larger-streams">Local respiration rates are positively correlated with watershed area except in larger streams</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/guerrero_etal_23_scaling_local_respiration_rates.png" class="img-fluid figure-img" width="687"></p>
<figcaption class="figure-caption">Local respiration rates (normalized by stream surface area) increase positively with watershed area up to stream order 5.</figcaption>
</figure>
</div>
</section>
<section id="precipitation-regime-has-a-stronger-influence-on-the-relationship-between-local-respiration-rates-and-watershed-area-in-the-yakima-river-basin-than-in-the-willamette-river-basin" class="level3">
<h3 class="anchored" data-anchor-id="precipitation-regime-has-a-stronger-influence-on-the-relationship-between-local-respiration-rates-and-watershed-area-in-the-yakima-river-basin-than-in-the-willamette-river-basin">Precipitation regime has a stronger influence on the relationship between local respiration rates and watershed area in the Yakima River Basin than in the Willamette river basin</h3>
<p><img src="images/guerrero_etal_23_scaling_local_respiration_rates_precipt.png" class="img-fluid" width="740"></p>
<ul>
<li>I will replace this one for another using mean annual runoff to show the non-uniform character of this variable.</li>
</ul>
</section>
</section>
<section id="section" class="level2">
<h2 class="anchored" data-anchor-id="section"></h2>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>